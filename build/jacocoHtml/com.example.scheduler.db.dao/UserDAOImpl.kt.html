<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="pl"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UserDAOImpl.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Scheduler</a> &gt; <a href="index.source.html" class="el_package">com.example.scheduler.db.dao</a> &gt; <span class="el_source">UserDAOImpl.kt</span></div><h1>UserDAOImpl.kt</h1><pre class="source lang-java linenums">package com.example.scheduler.db.dao

import com.example.scheduler.db.DBQueryExecutor
import org.mindrot.jbcrypt.BCrypt
import java.sql.DriverManager
import java.sql.SQLException

/**
 * Implementacja interfejsu `UserDAO` do obsługi operacji w bazie danych dla ekranu logowania.
 */
<span class="fc" id="L11">class UserDaoImpl : UserDAO {</span>

    /**
     * Identyfikuje użytkownika na podstawie dostarczonych danych.
     *
     * @param username Nazwa użytkownika do uwierzytelnienia.
     * @param password Hasło użytkownika do uwierzytelnienia.
     * @return Identyfikator roli użytkownika po uwierzytelnieniu lub 0 jeśli uwierzytelnianie nie powiodło się.
     */
    override fun authenticateUser(username: String, password: String): Int {
<span class="fc" id="L21">        var query = &quot;SELECT pass FROM user WHERE username=?&quot;</span>
<span class="pc" id="L22">        val hashedPassword = DBQueryExecutor.executeQuery(query, username) { resultSet -&gt;resultSet.getString(1)}.firstOrNull()</span>

<span class="pc bpc" id="L24" title="4 of 6 branches missed.">        if (!hashedPassword.isNullOrEmpty())</span>
        {
            //Porównaj zahashowane hasło z podanym
<span class="nc bnc" id="L27" title="All 2 branches missed.">            return if (BCrypt.checkpw(password, hashedPassword)) {</span>
                // Hasło jest poprawne, zezwól na uwierzytelnienie - pobierz rolę
<span class="nc" id="L29">                query = &quot;SELECT roleId FROM user_role AS ur\n&quot; +</span>
                        &quot;INNER JOIN user AS u ON u.userId = ur.userID\n&quot; +
                        &quot;WHERE u.username = ?&quot;
<span class="nc" id="L32">                DBQueryExecutor.executeQuery(query, username) { resultSet -&gt;</span>
<span class="nc" id="L33">                    resultSet.getInt(1)</span>
<span class="nc" id="L34">                }.first()</span>


            } else {
                // Hasło jest niepoprawne, odrzuć uwierzytelnienie
<span class="nc" id="L39">                0</span>
            }
        }
<span class="fc" id="L42">        return 0</span>
    }

    /**
     * Zastępuje tymczasowe hasło nowym hasłem dla określonego użytkownika.
     *
     * @param newPassword Nowe hasło, które ma zostać ustawione.
     * @param username    Nazwa użytkownika, dla którego ma zostać zmienione hasło.
     */
    @Throws(SQLException::class)
    override fun changeTempPassword(newPassword: String, username: String) {
<span class="nc" id="L53">        val query = &quot;{ CALL updatePassword(?,?) }&quot;</span>
<span class="nc" id="L54">        DBQueryExecutor.executePreparedStatement(query, newPassword, username)</span>
<span class="nc" id="L55">    }</span>

    /**
     * Sprawdza, czy hasło dla danego użytkownika jest tymczasowe.
     *
     * @param username Nazwa użytkownika, dla którego sprawdzane jest hasło.
     * @param password Hasło, które ma zostać sprawdzone.
     * return Wartość logiczna informująca, czy hasło jest tymczasowe (true) lub nie (false).
     */
    override fun isPasswordTemp(username: String, password: String): Boolean {
<span class="nc" id="L65">        val query = &quot;SELECT isTempPassword FROM user WHERE username=?&quot;</span>
<span class="nc" id="L66">        return DBQueryExecutor.executeQuery(query, username) {resultSet -&gt; resultSet.getBoolean(1) }.first()</span>
    }

    /**
     * Testuje hasło do bazy danych podane przez użytkownika
     * @param db Baza danych, do której użytkownik ma się połączyć
     * @param username Nazwa użytkownika bazy danych
     * @param pass Hasło do bazy danych
     */
    override fun testDBPassword(db: String, username: String, pass: String): Boolean {
<span class="nc" id="L76">        return try {</span>
<span class="nc" id="L77">            val conn = DriverManager.getConnection(db,username, pass)</span>
<span class="nc" id="L78">            conn.close()</span>
<span class="nc" id="L79">            true</span>
<span class="nc" id="L80">        }catch (e: Exception) {</span>
<span class="nc" id="L81">            false</span>
        }

    }

    /*
    override fun checkIfPasswordIsOccupied(password: String): Boolean {
        val query = &quot;SELECT pass FROM user&quot;
        val hashedPasswordsFromDatabase = DBQueryExecutor.executeQuery(query) {resultSet -&gt; resultSet.getString(1) }
        return hashedPasswordsFromDatabase.any { hashedPassword -&gt; BCrypt.checkpw(password, hashedPassword) }
    }

     */
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>