<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="pl"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RoomDAOImpl.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Scheduler</a> &gt; <a href="index.source.html" class="el_package">com.example.scheduler.db.dao</a> &gt; <span class="el_source">RoomDAOImpl.kt</span></div><h1>RoomDAOImpl.kt</h1><pre class="source lang-java linenums">package com.example.scheduler.db.dao

import com.example.scheduler.db.DBQueryExecutor
import com.example.scheduler.objects.Room
import javafx.collections.ObservableList
import java.sql.SQLException

/**
 * Implementacja interfejsu `RoomDAO` do obsługi operacji w bazie danych dla sal
 */
<span class="fc" id="L11">class RoomDAOImpl: RoomDAO {</span>

    /**
     * Pobiera listę sal z danej lokalizacji z bazy danych.
     *
     * @param location Nazwa lokalizacji.
     * @return         Lista obiektów Room reprezentujących sale.
     */
    override fun getRooms(location: String): ObservableList&lt;Room&gt; {
<span class="fc" id="L20">        val query = &quot;SELECT roomName, volume, floor, l.name FROM rooms &quot; +</span>
                &quot;INNER JOIN location_room AS lr ON lr.roomID = rooms.roomID &quot; +
                &quot;INNER JOIN location l on lr.locationID = l.locationId &quot; +
                &quot; WHERE lr.locationID = (SELECT locationID &quot; +
                &quot;FROM location WHERE name = ? )&quot;


<span class="fc" id="L27">        return DBQueryExecutor.executeQuery(query, location){</span>
                resultSet -&gt;
<span class="fc" id="L29">            Room(</span>
<span class="fc" id="L30">                roomName = resultSet.getString(1),</span>
<span class="fc" id="L31">                volume = resultSet.getInt(2),</span>
<span class="fc" id="L32">                floor = resultSet.getInt(3),</span>
<span class="fc" id="L33">                location = resultSet.getString(4))</span>
        }
    }

    /**
     * Metoda pobierająca id podanej sali.
     *
     * @param room Obiekt Room, którego id chcemy uzyskać
     * @return Id sali
     */
    override fun getRoomID(room: Room): Int {
<span class="fc" id="L44">        val query = &quot;SELECT lr.roomID FROM rooms INNER JOIN location_room AS lr ON lr.roomID = rooms.roomID &quot; +</span>
                &quot;WHERE roomName = ? AND lr.locationID = (SELECT locationID FROM location AS l WHERE &quot; +
                &quot; l.name = ? ) AND volume = ? AND floor = ?&quot;

<span class="fc" id="L48">        return DBQueryExecutor.executeQuery(query,</span>
<span class="fc" id="L49">            room.roomName,</span>
<span class="fc" id="L50">            room.location,</span>
<span class="fc" id="L51">            room.volume,</span>
<span class="fc" id="L52">            room.floor</span>
        )
<span class="fc" id="L54">        {resultSet -&gt; resultSet.getInt(1)}.first()</span>
    }

    /**
     * Sprawdza, czy sala w danej lokalizacji, istnieje w bazie danych.
     *
     * @param roomName          Nazwa sali
     * @param locationName      Nazwa lokalizacji
     * @return                  `true`, jeśli sala istnieje w danej lokalizacji; `false` w przeciwnym razie.
     */
    override fun checkIfRoomInDb(roomName: String, locationName: String): Boolean {
<span class="fc" id="L65">        val query = &quot;SELECT COUNT(*) FROM rooms INNER JOIN location_room AS lr ON lr.roomID = rooms.roomID &quot; +</span>
                &quot;WHERE roomName = ? AND locationID = (SELECT locationID FROM location WHERE location.name = ? ) &quot;

<span class="fc" id="L68">        return DBQueryExecutor.executeQuery(</span>
<span class="fc" id="L69">            query,</span>
<span class="fc" id="L70">            roomName,</span>
<span class="fc" id="L71">            locationName</span>
<span class="fc" id="L72">        ){ resultSet -&gt; resultSet.getBoolean(1) }.first()</span>
    }

    /**
     * Metoda dodająca salę do bazy danych przy użyciu procedury z bazy danych.
     *
     * @param room Sala do dodania do bazy danych
     */
    @Throws(SQLException::class)
    override fun addRoom(room: Room) {
<span class="fc" id="L82">        val query = &quot;{ CALL addRoom(?,?,?,?) }&quot;</span>
<span class="fc" id="L83">        DBQueryExecutor.executePreparedStatement(</span>
<span class="fc" id="L84">            query,</span>
<span class="fc" id="L85">            room.roomName,</span>
<span class="fc" id="L86">            room.volume,</span>
<span class="fc" id="L87">            room.floor,</span>
<span class="fc" id="L88">            room.location</span>
        )
<span class="fc" id="L90">    }</span>

    /**
     * Metoda aktualizująca salę w bazie danych przy użyciu procedury z bazy danych.
     *
     * @param roomID Id sali do aktualizacji
     * @param room Sala ze zaktualizowanymi danymi
     */
    @Throws(SQLException::class)
    override fun updateRoom(roomID: Int, room: Room) {
<span class="nc" id="L100">        val query = &quot;{ CALL updateRoom(?,?,?,?,?) }&quot;</span>
<span class="nc" id="L101">        DBQueryExecutor.executePreparedStatement(</span>
<span class="nc" id="L102">            query,</span>
<span class="nc" id="L103">            roomID,</span>
<span class="nc" id="L104">            room.roomName,</span>
<span class="nc" id="L105">            room.location,</span>
<span class="nc" id="L106">            room.volume,</span>
<span class="nc" id="L107">            room.floor</span>
        )
<span class="nc" id="L109">    }</span>

    /**
     * Metoda usuwająca salę z bazy danych.
     * Przy usuwaniu sali, zajęcia, które planowo miały się odbyć
     * w niej są zastępowane salą wirtualną
     *
     * @param room Sala do usunięcia
     */
    @Throws(SQLException::class)
    override fun deleteRoom(room: Room) {
<span class="fc" id="L120">        val query = &quot;{ CALL deleteRoom(?,?,?,?) }&quot;</span>
<span class="fc" id="L121">        DBQueryExecutor.executePreparedStatement(</span>
<span class="fc" id="L122">            query,</span>
<span class="fc" id="L123">            room.roomName,</span>
<span class="fc" id="L124">            room.volume,</span>
<span class="fc" id="L125">            room.floor,</span>
<span class="fc" id="L126">            room.location</span>
        )
<span class="fc" id="L128">    }</span>

    /**
     * Sprawdza, czy sala (inna niż 'lastSelectedRoom') w danej lokalizacji, istnieje w bazie danych.
     *
     * @param roomName              Nazwa sali
     * @param location              Nazwa lokalizacji
     * @param lastSelectedRoom Sala do pominięcia przy sprawdzaniu
     * @return                      `true`, jeśli sala istnieje w danej lokalizacji; `false` w przeciwnym razie.
     */
    override fun checkIfRoomInDbEdit(roomName: String, location: String, lastSelectedRoom: Room): Boolean {
<span class="fc" id="L139">        val query = &quot;SELECT COUNT(*) FROM rooms INNER JOIN location_room AS lr ON lr.roomID = rooms.roomID &quot; +</span>
                &quot;WHERE roomName = ? AND locationID = (SELECT locationID FROM location WHERE location.name = ? ) &quot; +
                &quot;AND rooms.roomID != (SELECT r.roomID FROM rooms AS r INNER JOIN location_room AS lr ON lr.roomID = r.roomID WHERE r.roomName = ? AND r.volume = ? AND r.floor=? &quot; +
                &quot;AND lr.locationID = (SELECT locationID FROM location WHERE location.name = ? ))&quot;

<span class="fc" id="L144">        return DBQueryExecutor.executeQuery(</span>
<span class="fc" id="L145">            query,</span>
<span class="fc" id="L146">            roomName,</span>
<span class="fc" id="L147">            location,</span>
<span class="fc" id="L148">            lastSelectedRoom.roomName,</span>
<span class="fc" id="L149">            lastSelectedRoom.volume,</span>
<span class="fc" id="L150">            lastSelectedRoom.floor,</span>
<span class="fc" id="L151">            lastSelectedRoom.location</span>
<span class="fc" id="L152">        ){ resultSet -&gt; resultSet.getBoolean(1) }.first()</span>
    }

    /**
     * Pobiera wszystkie sale dla określonej lokalizacji.
     *
     * @param location Nazwa lokalizacji.
     * @return Lista sal w danej lokalizacji.
     */
    override fun getRoomsByLocation(location: String): ObservableList&lt;String&gt; {
<span class="nc" id="L162">        val query = &quot;SELECT roomName from rooms &quot; +</span>
                &quot;INNER JOIN location_room AS lr ON lr.roomID = rooms.roomID &quot; +
                &quot;INNER JOIN location l on l.locationID = lr.locationID &quot; +
                &quot;WHERE l.name = ?&quot;

<span class="nc" id="L167">        return DBQueryExecutor.executeQuery(query,location){</span>
<span class="nc" id="L168">                resultSet -&gt; resultSet.getString(1) }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>