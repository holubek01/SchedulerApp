<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="pl"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClassesDAOImpl.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Scheduler</a> &gt; <a href="index.source.html" class="el_package">com.example.scheduler.db.dao</a> &gt; <span class="el_source">ClassesDAOImpl.kt</span></div><h1>ClassesDAOImpl.kt</h1><pre class="source lang-java linenums">package com.example.scheduler.db.dao

import com.example.scheduler.db.DBQueryExecutor
import com.example.scheduler.models.ClassesToRead
import com.example.scheduler.models.ClassesToWrite
import com.example.scheduler.utils.MessageBundle
import javafx.collections.FXCollections
import javafx.collections.ObservableList
import java.sql.SQLException
import java.time.LocalDate

/**
 * Implementacja interfejsu 'ClassesDAO' do obsługi operacji w bazie danych dla zajęć.
 */
<span class="fc" id="L15">class ClassesDAOImpl: ClassesDAO{</span>

    /**
     * Pobiera listę nazw kierunków kształcenia, dla których plan nie jest jeszcze w pełni ułożony
     * (istnieją grupy na kierunku, dla których plan nie jest w pełni utworzony).
     *
     * @return Lista nazw kierunków studiów, dla których plan nie jest jeszcze w pełni ułożony.
     */
    override fun getFields(): ObservableList&lt;String&gt; {

<span class="fc" id="L25">        val query: String = &quot;SELECT distinct fieldName FROM `fields` \n&quot; +</span>
                    &quot;INNER JOIN field_subject ON field_subject.fieldID = fields.fieldID\n&quot; +
                    &quot;INNER JOIN group_field ON group_field.fieldID = fields.fieldID\n&quot; +
                    &quot;INNER JOIN group_subject_hours_left ON group_subject_hours_left.groupID = group_field.groupID\n&quot; +
                    &quot;WHERE weekHoursLeft &gt; 0 ORDER BY fieldName&quot;

<span class="fc" id="L31">        return DBQueryExecutor.executeQuery(query){ resultSet -&gt; resultSet.getString(1) }</span>
    }


    /**
     * Pobiera listę przedmiotów dla danej grupy i kierunku, dla których plan nie jest jeszcze w pełni ułożony.
     *  @param group Nazwa grupy
     *  @param field Nazwa kierunku, do którego przypisana jest grupa
     *
     * @return Lista przedmiotów dla danej grupy i kierunku, dla których plan nie jest jeszcze w pełni ułożony.
     */
    override fun getSubjects(group: String, field: String): ObservableList&lt;String&gt; {

<span class="fc" id="L44">        val query = &quot;SELECT DISTINCT subjects.subjectName FROM group_subject_hours_left\n&quot; +</span>
                &quot;INNER JOIN subjects ON subjects.subjectID = group_subject_hours_left.subjectID\n&quot; +
                &quot;WHERE group_subject_hours_left.groupID=(SELECT `groups`.groupID FROM `groups` INNER JOIN group_field ON group_field.groupID =\n&quot; +
                &quot;`groups`.groupID INNER JOIN fields ON fields.fieldID = group_field.fieldID\n&quot; +
                &quot;WHERE groupName=? AND fieldName=?) AND group_subject_hours_left.weekHoursLeft &gt; 0 ORDER BY subjects.subjectName&quot;


<span class="fc" id="L51">        return DBQueryExecutor.executeQuery(query, group, field){ resultSet -&gt; resultSet.getString(1) }</span>
    }

    /**
     * Pobiera liczbę godzin, która, została do ułożenia planu dla wybranej grupy i przedmiotu
     * (ile godzin zostało do zrealizowania szkolnego planu nauczania)
     * @param group Nazwa grupy
     * @param field Nazwa kierunku, do którego przypisana jest grupa
     * @param subject Nazwa kierunku, dla którego należy sprawdzić godziny
     * @return Liczba godzin, które pozostała do pełnego ułożenia planu dla grupy i przedmiotu
     */
    override fun getHowManyHoursLeft(group: String, field: String, subject: String): Int {
<span class="fc" id="L63">        val query = &quot;SELECT DISTINCT group_subject_hours_left.weekHoursLeft FROM group_subject_hours_left\n&quot; +</span>
                &quot;INNER JOIN subjects ON subjects.subjectID = group_subject_hours_left.subjectID\n&quot; +
                &quot;WHERE group_subject_hours_left.groupID=(SELECT `groups`.groupID FROM `groups` INNER JOIN group_field ON group_field.groupID =\n&quot; +
                &quot;`groups`.groupID INNER JOIN fields ON fields.fieldID = group_field.fieldID\n&quot; +
                &quot;WHERE groupName=? AND fieldName=?) AND subjects.subjectName = ?&quot;

<span class="fc" id="L69">        return DBQueryExecutor.executeQuery(query, group, field, subject){ resultSet -&gt; resultSet.getInt(1) }.first()</span>
    }

    /**
     * Pobiera listę godzin, w których dana grupa nie jest zajęta w wybranym dniu.
     * @param group Nazwa grupy
     * @param field Nazwa kierunku, do którego przypisana jest grupa
     * @param day Dzień, w którym należy sprawdzić godziny
     *
     * @return Lista godzin, w których dana grupa nie jest zajęta.
     */
    override fun getHours(day: LocalDate, group: String, field: String): ObservableList&lt;String&gt; {
<span class="fc" id="L81">        val query = &quot;SELECT DISTINCT hourRange FROM hours WHERE hourID NOT IN (SELECT hourID FROM plan WHERE date=? &quot; +</span>
            &quot;AND groupId = (SELECT group_field.groupID FROM `groups` INNER JOIN group_field ON group_field.groupID = `groups`.groupID&quot; +
            &quot; INNER JOIN fields ON fields.fieldID = group_field.fieldID WHERE groupName = ? AND fieldName = ?))&quot;

<span class="fc" id="L85">        return DBQueryExecutor.executeQuery(query, day, group, field){ resultSet -&gt; resultSet.getString(1) }</span>
    }

    /**
     * Pobiera listę sal w podanej lokalizacji, które w danym dniu o danej godzinie nie są zajęte przez inną grupę.
     * @param day Dzień, w którym należy sprawdzić zajętość sal
     * @param hour Godzina, w której należy sprawdzić zajętość sal
     * @param location Lokalizacja, w której należy sprawdzić sale
     *
     * @return Lista wolnych sal w danej lokalizacji w podanym terminie.
     */
    override fun getRooms(day: LocalDate, hour: String, location: String): ObservableList&lt;String&gt; {
<span class="fc" id="L97">        val query: String =</span>
<span class="fc" id="L98">            &quot;SELECT DISTINCT roomName FROM rooms INNER JOIN location_room AS lr ON lr.roomID = rooms.roomID WHERE lr.roomID not in (SELECT roomID FROM plan WHERE date=? &quot; +</span>
                    &quot;AND hourId= (SELECT hourID from hours WHERE hourRange=?)) AND locationID = &quot; +
                    &quot;(SELECT locationId FROM location WHERE name=?)&quot;


<span class="fc" id="L103">        return DBQueryExecutor.executeQuery(query, day, hour, location){ resultSet -&gt; resultSet.getString(1) }</span>
    }


    /**
     * Pobiera listę nauczycieli, którzy nie mają w podanym terminie innych zajęć oraz uczą wybranego przedmiotu
     * i zadeklarowali swoją dyspozycyjność w podanym terminie.
     *
     * @return Lista nauczycieli, których można przypisać do zajęć w tym terminie.
     */
    override fun getTeachers(day: LocalDate, hour: String, subject: String): ObservableList&lt;String&gt; {

<span class="fc" id="L115">        val query = &quot;SELECT DISTINCT lastname, name FROM teachers INNER JOIN availability ON availability.teacherID = teachers.teacherID &quot; +</span>
                &quot;WHERE teachers.teacherID IN (SELECT teacherID from availability WHERE dayID = (SELECT dayID from day_of_week WHERE&quot; +
                &quot; dayName = ?) AND hourID = (SELECT hourID FROM hours WHERE hourRange=?)) AND teachers.teacherID NOT IN&quot; +
                &quot;  (SELECT teacherId FROM plan WHERE date=? AND hourId = (SELECT hourID FROM hours WHERE hourRange=?)) AND &quot; +
                &quot;teachers.teacherID IN (SELECT teacherID from teacher_subject INNER JOIN subjects ON subjects.subjectID =&quot; +
                &quot; teacher_subject.subjectID WHERE subjectName = ?) ORDER BY lastname, name&quot;

<span class="fc" id="L122">        return DBQueryExecutor.executeQuery(query,day.dayOfWeek.toString().uppercase(),hour,day, hour,subject){ resultSet -&gt; &quot;${resultSet.getString(1)} ${resultSet.getString(2)}&quot;  }</span>
    }

    /**
     * Pobiera listę nauczycieli i odpowiadających im godzin w wybranym dniu, w których mogą prowadzić zajęcia z wybranego przedmiotu
     * @param subject Przedmiot, którego musi uczyć nauczyciel
     * @param date Data, w której należy sprawdzić dyspozycyjność nauczycieli
     * @return lista nauczycieli i odpowiadających im godzin w wybranym dniu, w których mogą prowadzić zajęcia z wybranego przedmiotu
     */
    override fun getTeacherWithHoursHint(subject: String, date: LocalDate): ObservableList&lt;Pair&lt;String, String&gt;&gt; {
<span class="fc" id="L132">        val query = &quot;SELECT DISTINCT CONCAT(lastname, ' ', name) as teacher, h.hourRange FROM teachers AS t \n&quot; +</span>
                &quot;INNER JOIN teacher_subject AS ts ON ts.teacherID = t.teacherID\n&quot; +
                &quot;INNER JOIN subjects AS s ON s.subjectID = ts.subjectID\n&quot; +
                &quot;INNER JOIN availability AS a ON a.teacherID = t.teacherID\n&quot; +
                &quot;INNER JOIN hours AS h ON h.hourId = a.hourID\n&quot; +
                &quot;WHERE s.subjectName = ?\n&quot; +
                &quot;AND (t.teacherID,h.hourId) NOT IN (SELECT teacherId, hourId FROM plan AS p WHERE p.date = ?)\n&quot; +
                &quot;AND a.dayID = (SELECT dayID FROM day_of_week WHERE dayName = dayname(?))&quot;

<span class="fc" id="L141">        return DBQueryExecutor.executeQuery(query,subject,date,date){ resultSet -&gt; Pair(resultSet.getString(1), resultSet.getString(2))  }</span>
    }


    /**
     * Metoda, która dodaje zajęcia do planu, wykorzystująca procedurę z bazy danych.
     *
     * @param classes Obiekt reprezentujący pojedyńcze zajęcia do dodania do planu.
     */
    @Throws(SQLException::class)
    override fun addToPlan(classes: ClassesToWrite) {
<span class="fc" id="L152">        val query = &quot;{ CALL addToPlan(?,?,?,?,?,?,?,?,?) }&quot;</span>

<span class="fc" id="L154">        return  DBQueryExecutor.executePreparedStatement(</span>
<span class="fc" id="L155">            query,</span>
<span class="fc" id="L156">            classes.date!!,</span>
<span class="fc" id="L157">            classes.hour!!,</span>
<span class="fc" id="L158">            classes.room!!,</span>
<span class="fc" id="L159">            classes.group!!,</span>
<span class="fc" id="L160">            classes.teacher!!.split(&quot; &quot;)[1],</span>
<span class="fc" id="L161">            classes.teacher!!.split(&quot; &quot;)[0],</span>
<span class="fc" id="L162">            classes.subject!!,</span>
<span class="fc" id="L163">            classes.fieldOfStudy!!,</span>
<span class="fc" id="L164">            classes.location!!</span>
        )
    }

    /**
     * Sprawdza, czy nauczyciel zdąży przenieść się pomiędzy lokalizacjami w danym dniu i godzinie
     * (Nauczyciel na zmianę lokalizacji powinien mieć odpowiednio długą przerwę odpowiadającą długości trwania co najmniej 1 zajęć).
     *
     * @param firstname Imię nauczyciela.
     * @param lastname Nazwisko nauczyciela.
     * @param location Lokalizacja, w której odbywają się następne zajęcia.
     * @param hour Godzina, w której odbywają się zajęcia.
     * @param date Data, w której odbywają się zajęcia.
     * @return true, jeśli nauczyciel zdąży przenieść się między zajęciami, false w przeciwnym razie.
     */
    override fun canTeacherMoveBetweenClasses(firstname: String, lastname: String, location: String, hour: String, date: String): Boolean {
<span class="fc" id="L180">        val query= &quot;{ ? = call canTeacherMoveBetweenClasses(?, ?, ?, ?, ?) }&quot;</span>
<span class="fc" id="L181">        return DBQueryExecutor.executeFunction(query, firstname, lastname, location, hour, date)</span>
    }


    /**
     * Sprawdza, czy grupa zdąży przenieść się pomiędzy lokalizacjami w danym dniu i godzinie
     * (Grupa na zmianę lokalizacji powinna mieć odpowiednio długą przerwę odpowiadającą długości trwania co najmniej 1 zajęć).
     *
     * @param group Nazwa grupy.
     * @param field Nazwa kierunku kształcenia.
     * @param location Lokalizacja, w której odbywają się zajęcia.
     * @param hour Godzina, w której odbywają się zajęcia.
     * @param date Data, w której odbywają się zajęcia.
     * @return true, jeśli grupa zdąży przenieść się między zajęciami, false w przeciwnym razie.
     */
    override fun canGroupMoveBetweenClasses(group: String, field: String, location: String, hour: String, date: String): Boolean {
<span class="fc" id="L197">        val query= &quot;{ ? = call canGroupMoveBetweenClasses(?, ?, ?, ?, ?) }&quot;</span>
<span class="fc" id="L198">        return DBQueryExecutor.executeFunction(query, group, field, location, hour, date)</span>
    }



    /**
     * Pobiera nauczycieli, którzy są wolni w określonym dniu i godzinie, zgłosili
     * dyspozycyjność oraz uczą określonego przedmiotu.
     *
     * @param subject Nazwa przedmiotu, którego nauczyciel musi nauczać.
     * @param date Data.
     * @param hour Godzina.
     * @return Lista nazw nauczycieli w formacie &quot;Nazwisko Imię&quot;, którzy są wolni w określonym czasie.
     */
    override fun getFreeTeachers(subject: String, date: LocalDate, hour: String): ObservableList&lt;String&gt;{
<span class="fc" id="L213">        val query = &quot;SELECT DISTINCT CONCAT(lastname, ' ', name) as teacher FROM teachers INNER JOIN availability ON availability.teacherID = teachers.teacherID &quot; +</span>
                &quot;WHERE teachers.teacherID IN (SELECT teacherID from availability WHERE dayID = (SELECT dayID from day_of_week WHERE&quot; +
                &quot; dayName = ?) AND hourID = (SELECT hourID FROM hours WHERE hourRange=?)) AND teachers.teacherID NOT IN&quot; +
                &quot;  (SELECT teacherId FROM plan WHERE date=? AND hourId = (SELECT hourID FROM hours WHERE hourRange=?)) AND &quot; +
                &quot;teachers.teacherID IN (SELECT teacherID from teacher_subject INNER JOIN subjects ON subjects.subjectID =&quot; +
                &quot; teacher_subject.subjectID WHERE subjectName = ?) ORDER BY lastname&quot;

<span class="fc" id="L220">        return DBQueryExecutor.executeQuery(query,date.dayOfWeek.toString().uppercase(),hour,date, hour,subject){ resultSet -&gt; resultSet.getString(1)}}</span>



    /**
     * Pobiera lokalizacje, dla których w wybranym dniu istnieją wolne sale
     * (może zdarzyć się, że w wybranym dniu we wszystkich godzinach wszystkie sale są zajęte)
     * @param day Dzień, w którym należy sprawdzić dyspozycyjność sal
     *
     * @return Lista nazw lokalizacji.
     */
    override fun getLocations(day: LocalDate): ObservableList&lt;String&gt; {
<span class="fc" id="L232">        val query = &quot;SELECT name FROM (SELECT DISTINCT l.name FROM location_room AS lr \n&quot; +</span>
                &quot;INNER JOIN location AS l ON l.locationId = lr.locationId\n&quot; +
                &quot;INNER JOIN rooms AS r ON r.roomID = lr.roomID \n&quot; +
                &quot;WHERE r.roomID IN ( \n&quot; +
                &quot;SELECT r.roomId FROM rooms AS r WHERE r.roomId NOT IN ( \n&quot; +
                &quot;SELECT p.roomID FROM plan AS p WHERE p.date = ? GROUP BY p.roomID \n&quot; +
                &quot;HAVING COUNT(p.roomID) = (SELECT COUNT(*) FROM hours)))\n&quot; +
                &quot;UNION (SELECT 'Platform' AS name)) AS result\n&quot; +
                &quot;ORDER BY name&quot;
<span class="fc" id="L241">        return DBQueryExecutor.executeQuery(query,day){ resultSet -&gt; resultSet.getString(1) }</span>
    }

    /**
     * Pobiera nauczycieli, którzy są zajęci w podanym terminie, ale uczą wybranego przedmiotu
     * Wykorzystywane przy generowaniu podpowiedzi, gdy brakuje nauczycieli
     */
    override fun getBusyTeachersHint(subject: String, date:String, hour:String): ObservableList&lt;String&gt; {
<span class="fc" id="L249">        val query = &quot;SELECT DISTINCT CONCAT(lastname, ' ', name) as teacher FROM teachers AS t \n&quot; +</span>
                &quot;INNER JOIN teacher_subject AS ts ON ts.teacherID = t.teacherID\n&quot; +
                &quot;INNER JOIN subjects AS s ON s.subjectID = ts.subjectID\n&quot; +
                &quot;WHERE s.subjectName = ?\n&quot; +
                &quot;AND t.teacherID IN \n&quot; +
                &quot;(SELECT teacherId FROM plan AS p WHERE p.date=? AND p.hourId=(SELECT hourID from hours \n&quot; +
                &quot;WHERE hourRange=?))&quot;

<span class="fc" id="L257">        return DBQueryExecutor.executeQuery(query,subject, date, hour){ resultSet -&gt; resultSet.getString(1)}</span>

    }

    /**
     * Pobiera nauczycieli, którzy są zajęci w określonym terminie, ale uczą wybranego przedmiotu, nauczyciel
     * z zajęć do edycji uczy przedmiotu, którego w tym czasie uczy proponowany nauczyciel
     * oraz nauczyciele prowadzą zajęcia w tej samej lokalizacji.
     *
     * @param subject Nazwa przedmiotu.
     * @param date Data.
     * @param hour Godzina.
     * @param subjects Lista nazw przedmiotów.
     * @param location Lokalizacja, w której nauczyciele muszą prowadzić zajęcia
     * @return Lista nauczycieli w formacie &quot;Nazwisko Imię&quot;, którzy są zajęci w określonym czasie ale uczą określonych przedmiotów.
     */
    override fun getBusyTeachers(
        subject: String,
        date: LocalDate,
        hour: String,
        subjects: ObservableList&lt;String&gt;,
        location: String
    ): ObservableList&lt;String&gt; {

<span class="fc" id="L281">        val formattedSubjects = subjects.joinToString(&quot;, &quot;, &quot;(&quot;, &quot;)&quot;) { &quot;'$it'&quot; }</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">        val loc = if (location == MessageBundle.getMess(&quot;label.platform&quot;)) &quot;Platform&quot; else location</span>

<span class="fc" id="L284">        val query =</span>
            &quot;SELECT DISTINCT CONCAT(lastname, ' ', name) as teacher FROM teachers INNER JOIN availability ON availability.teacherID = teachers.teacherID &quot; +
                    &quot;INNER JOIN teacher_subject AS ts ON ts.teacherID = teachers.teacherID INNER JOIN subjects AS s ON s.subjectID = ts.subjectID WHERE teachers.teacherID IN (SELECT teacherID from availability WHERE dayID = (SELECT dayID from day_of_week WHERE&quot; +
                    &quot; dayName = ?) AND hourID = (SELECT hourID FROM hours WHERE hourRange=?)) AND teachers.teacherID IN&quot; +
                    &quot;  (SELECT teacherId FROM plan WHERE plan.roomId IN (SELECT roomId FROM location_room AS lr \n&quot; +
                    &quot;INNER JOIN location AS l\n&quot; +
                    &quot;ON l.locationID = lr.locationID WHERE l.name = ?) AND date=? AND hourId = (SELECT hourID FROM hours WHERE hourRange=?)) AND &quot; +
                    &quot;teachers.teacherID IN (SELECT teacherID from teacher_subject INNER JOIN subjects ON subjects.subjectID =&quot; +
                    &quot; teacher_subject.subjectID WHERE subjectName = ?) AND teachers.teacherID IN &quot; +
                    &quot;(SELECT teacherID FROM plan INNER JOIN subjects ON subjects.subjectID = plan.subjectId WHERE plan.date=?\n&quot; +
<span class="fc" id="L294">                    &quot;AND plan.hourID = (SELECT hourID FROM hours WHERE hourRange=?) AND subjects.subjectName IN $formattedSubjects) &quot; +</span>
                    &quot; ORDER BY lastname&quot;

<span class="fc" id="L297">        return DBQueryExecutor.executeQuery(query, date.dayOfWeek.toString().uppercase(), hour, loc, date, hour, subject, date, hour) { resultSet -&gt; resultSet.getString(1) }</span>

    }


    /**
     * Zamienia nauczyciela na danych zajęciach na innego wolnego nauczyciela.
     *
     * @param firstTeacher Imię i nazwisko pierwszego nauczyciela w formacie &quot;Nazwisko Imię&quot;.
     * @param secondTeacher Imię i nazwisko drugiego nauczyciela w formacie &quot;Nazwisko Imię&quot;.
     * @param classes Edytowane zajęcia.
     */
    @Throws(SQLException::class)
    override fun setAnotherTeacher(firstTeacher: String, secondTeacher: String, classes: ClassesToRead) {
<span class="fc" id="L311">        val query = &quot;{ CALL setAnotherTeacher(?,?,?,?,?,?,?,?,?,?,?) }&quot;</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        val location = if (classes.room.split(&quot;, &quot;)[1] == MessageBundle.getMess(&quot;label.platform&quot;)) &quot;Platform&quot; else classes.room.split(&quot;, &quot;)[1]</span>
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        val room = if (classes.room.split(&quot;, &quot;)[0] == MessageBundle.getMess(&quot;label.virtual&quot;)) &quot;Virtual&quot; else classes.room.split(&quot;, &quot;)[0]</span>

<span class="fc" id="L315">        return  DBQueryExecutor.executePreparedStatement(</span>
<span class="fc" id="L316">            query,</span>
<span class="fc" id="L317">            classes.teacher.split(&quot; &quot;)[1],</span>
<span class="fc" id="L318">            classes.teacher.split(&quot; &quot;)[0],</span>
<span class="fc" id="L319">            secondTeacher.split(&quot; &quot;)[1],</span>
<span class="fc" id="L320">            secondTeacher.split(&quot; &quot;)[0],</span>
<span class="fc" id="L321">            classes.date,</span>
<span class="fc" id="L322">            classes.hour,</span>
<span class="fc" id="L323">            room,</span>
<span class="fc" id="L324">            classes.group.split(&quot;, &quot;)[0],</span>
<span class="fc" id="L325">            classes.subject,</span>
<span class="fc" id="L326">            classes.group.split(&quot;, &quot;)[1],</span>
<span class="fc" id="L327">            location</span>
        )
    }

    /**
     * Pobiera listę grup na podanym kierunku, dla których plan nie jest jeszcze w pełni ułożony.
     *
     * @return Lista grup na podanym kierunku, dla których plan nie jest jeszcze w pełni ułożony.
     */
    override fun getGroups(field: String): ObservableList&lt;String&gt; {

<span class="fc" id="L338">        val query: String =</span>
<span class="fc" id="L339">            &quot;SELECT DISTINCT groupName FROM `groups`\n&quot; +</span>
                    &quot;INNER JOIN group_field ON group_field.groupID = `groups`.groupID\n&quot; +
                    &quot;INNER JOIN group_subject_hours_left ON group_subject_hours_left.groupID = group_field.groupID\n&quot; +
                    &quot;WHERE fieldID = (SELECT fieldID FROM fields WHERE fieldName=?) \n&quot; +
                    &quot;AND group_subject_hours_left.weekHoursLeft&gt;0\n&quot; +
                    &quot;ORDER BY\n&quot; +
                    &quot;  CASE\n&quot; +
                    &quot;    WHEN groupName LIKE 'I%' THEN 1\n&quot; +
                    &quot;    WHEN groupName LIKE 'II%' THEN 2\n&quot; +
                    &quot;    WHEN groupName LIKE 'III%' THEN 3\n&quot; +
                    &quot;    WHEN groupName LIKE 'IV%' THEN 4\n&quot; +
                    &quot;    WHEN groupName LIKE 'V%' THEN 5\n&quot; +
                    &quot;    WHEN groupName LIKE 'VI%' THEN 6\n&quot; +
                    &quot;    WHEN groupName LIKE 'VII%' THEN 7\n&quot; +
                    &quot;    WHEN groupName LIKE 'VIII%' THEN 8\n&quot; +
                    &quot;    WHEN groupName LIKE 'IX%' THEN 9\n&quot; +
                    &quot;    WHEN groupName LIKE 'X%' THEN 10\n&quot; +
                    &quot;  END,\n&quot; +
                    &quot;  groupName;&quot;


<span class="fc" id="L360">        return DBQueryExecutor.executeQuery(query, field){ resultSet -&gt; resultSet.getString(1) }</span>
    }


    /**
     * Pobiera sale, które w określonym czasie są wolne.
     *
     * @param classes Obiekt reprezentujący edytowane zajęcia.
     * @param locations Lista lokalizacji, z których można sprawdzić (nauczyciel lub grupa zdąży się do tych sal przemieścić)
     * @return Lista wolnych sal w określonym czasie.
     */
    override fun getFreeRooms(classes: ClassesToRead, locations: ObservableList&lt;String&gt;): ObservableList&lt;String&gt; {

<span class="fc" id="L373">        val formattedLocations = locations.joinToString(&quot;, &quot;, &quot;(&quot;, &quot;)&quot;) { &quot;'$it'&quot; }</span>

<span class="fc" id="L375">        val query = &quot;SELECT CONCAT(r.roomName, ', ', l.name) AS rooms FROM rooms AS r\n&quot; +</span>
                &quot;INNER JOIN location_room AS lr ON lr.roomID = r.roomID\n&quot;+
                &quot;INNER JOIN location AS l ON l.locationID = lr.locationID\n&quot; +
                &quot;WHERE r.roomID NOT IN \n&quot; +
<span class="fc" id="L379">                &quot;(SELECT roomId FROM plan AS p INNER JOIN hours AS h ON h.hourID = p.hourId WHERE p.date = ? AND h.hourRange = ?) AND l.name IN $formattedLocations&quot;</span>

<span class="fc" id="L381">        return DBQueryExecutor.executeQuery(query,</span>
<span class="fc" id="L382">            classes.date,</span>
<span class="fc" id="L383">            classes.hour</span>
<span class="fc" id="L384">        ){resultSet -&gt; resultSet.getString(1) }</span>
    }

    /**
     * Pobiera sale, które są zajęte w danym terminie i znajdują się w tej samej lokalizacji co sala z edytowanych zajęć.
     *
     * @param classes Edytowane zajęcia.
     * @return Lista zajętych sal
     */
    override fun getBusyRooms(classes: ClassesToRead): ObservableList&lt;String&gt; {
        //W przypadku platformy nie mogą istnieć zajęte sale w
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">        if (classes.room.split(&quot;, &quot;)[1] == MessageBundle.getMess(&quot;label.platform&quot;))</span>
        {
<span class="nc" id="L397">            return FXCollections.observableArrayList()</span>
        }
        else
        {
<span class="fc" id="L401">            val query = &quot;SELECT CONCAT(r.roomName, ', ', l.name) AS rooms FROM rooms AS r\n&quot; +</span>
            &quot;        INNER JOIN location_room AS lr ON lr.roomID = r.roomID\n&quot; +
                    &quot;        INNER JOIN location AS l ON l.locationID = lr.locationID\n&quot; +
                    &quot;        INNER JOIN plan AS p ON p.roomId = r.roomID\n&quot; +
                    &quot;        WHERE p.date = ? AND p.hourId = (SELECT hourID FROM hours WHERE hourRange = ?) AND l.name=?&quot;

<span class="fc" id="L407">            return DBQueryExecutor.executeQuery(query,</span>
<span class="fc" id="L408">                classes.date,</span>
<span class="fc" id="L409">                classes.hour,</span>
<span class="fc" id="L410">                classes.room.split(&quot;, &quot;)[1]</span>
<span class="fc" id="L411">            ){resultSet -&gt; resultSet.getString(1) }</span>
        }
    }

    /**
     * Pobiera listę wolnych sal w wybranej lokalizacji w danym terminie.
     *
     * @param date  Data zajęć
     * @param hour  Godzina zajęć
     * @param location Lokalizacja
     * @return Lista wolnych sal w wybranej lokalizacji w danym terminie.
     */
    override fun getFreeRoomsByHour(date: LocalDate, hour: String, location: String): ObservableList&lt;String&gt; {
<span class="fc" id="L424">        val query = &quot;SELECT CONCAT(roomName,', ', l.name) AS rooms FROM rooms AS r\n&quot; +</span>
                &quot;INNER JOIN location_room AS lr ON lr.roomID = r.roomID\n&quot; +
                &quot;INNER JOIN location AS l ON l.locationID = lr.locationID\n&quot; +
                &quot; WHERE r.roomID NOT IN \n&quot; +
                &quot;(SELECT DISTINCT roomID FROM plan AS p WHERE p.date = ? AND p.hourId = (SELECT hourID FROM hours WHERE hourRange = ?)) AND l.name = ?&quot;

<span class="fc" id="L430">        return DBQueryExecutor.executeQuery(query, date, hour, location){resultSet -&gt; resultSet.getString(1) }</span>
    }


    /**
     * Zmienia godzinę i salę podanych zajęć na inną wolną.
     *
     * @param selectedItem Nowa sala zajęć.
     * @param hour Nowa godzina zajęć
     * @param classes Obiekt reprezentujący zajęcia, dla których chcemy zmienić godzinę.
     */
    @Throws(SQLException::class)
    override fun changeHours(selectedItem: String, hour: String, classes: ClassesToRead) {
<span class="fc" id="L443">        val query = &quot;{ CALL changeHours(?,?,?,?,?,?,?,?,?,?,?,?) }&quot;</span>
<span class="fc" id="L444">        return  DBQueryExecutor.executePreparedStatement(query, classes.teacher.split(&quot; &quot;)[1], classes.teacher.split(&quot; &quot;)[0], classes.date, classes.hour, hour, classes.room.split(&quot;, &quot;)[0], selectedItem.split(&quot;, &quot;)[0], classes.group.split(&quot;, &quot;)[0], classes.subject, classes.group.split(&quot;, &quot;)[1], classes.room.split(&quot;, &quot;)[1], selectedItem.split(&quot;, &quot;)[1])</span>
    }


    /**
     * Zmienia godzinę podanych zajęć na inną (dla zajęć na platformie).
     *
     * @param hour Nowa godzina zajęć.
     * @param classes Obiekt reprezentujący zajęcia, dla których chcemy zmienić godzinę.
     */
    @Throws(SQLException::class)
    override fun changeHoursPlatform(hour: String, classes: ClassesToRead) {
<span class="fc" id="L456">        val query = &quot;{ CALL changeHourPlatform(?,?,?,?,?,?,?,?,?,?) }&quot;</span>
<span class="fc" id="L457">        return  DBQueryExecutor.executePreparedStatement(query, classes.teacher.split(&quot; &quot;)[1], classes.teacher.split(&quot; &quot;)[0], classes.date, classes.hour, hour, classes.room.split(&quot;, &quot;)[0], classes.group.split(&quot;, &quot;)[0], classes.subject, classes.group.split(&quot;, &quot;)[1], classes.room.split(&quot;, &quot;)[1])</span>
    }


    /**
     * Zmienia salę zajęć na inną wolną salę.
     *
     * @param selectedItem Nowa sala zajęć.
     * @param classes Obiekt reprezentujący edytowane zajęcia.
     */
    @Throws(SQLException::class)
    override fun setAnotherRoom(selectedItem: String, classes: ClassesToRead) {
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">        val locationTo = if (selectedItem.split(&quot;, &quot;)[1] == MessageBundle.getMess(&quot;label.platform&quot;)) &quot;Platform&quot; else selectedItem.split(&quot;, &quot;)[1]</span>
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">        val roomTo = if (selectedItem.split(&quot;, &quot;)[0] == MessageBundle.getMess(&quot;label.virtual&quot;)) &quot;Virtual&quot; else selectedItem.split(&quot;, &quot;)[0]</span>
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">        val locationFrom = if (classes.room.split(&quot;, &quot;)[1] == MessageBundle.getMess(&quot;label.platform&quot;)) &quot;Platform&quot; else classes.room.split(&quot;, &quot;)[1]</span>
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">        val roomFrom = if (classes.room.split(&quot;, &quot;)[0] == MessageBundle.getMess(&quot;label.virtual&quot;)) &quot;Virtual&quot; else classes.room.split(&quot;, &quot;)[0]</span>

<span class="fc" id="L474">        val query = &quot;{ CALL setAnotherRoom(?,?,?,?,?,?,?,?,?,?,?) }&quot;</span>
<span class="fc" id="L475">        return  DBQueryExecutor.executePreparedStatement(query, classes.teacher.split(&quot; &quot;)[1], classes.teacher.split(&quot; &quot;)[0], classes.date, classes.hour, roomFrom, roomTo, classes.group.split(&quot;, &quot;)[0], classes.subject, classes.group.split(&quot;, &quot;)[1], locationFrom, locationTo)</span>
    }

    /**
     * Zamienia sale na zajęciach (robi 2 updaty bo grupa, która odbywa zajęcia w sali, którą użytkownik chce przypisać też zmienia salę).
     *
     * @param selectedItem Nowa sala zajęć.
     * @param classes Obiekt reprezentujący edytowane zajęcia.
     */
    @Throws(SQLException::class)
    override fun changeRooms(selectedItem: String, classes: ClassesToRead) {
<span class="fc" id="L486">        val query = &quot;{ CALL changeRooms(?,?,?,?,?,?,?,?,?,?,?) }&quot;</span>
<span class="fc" id="L487">        return  DBQueryExecutor.executePreparedStatement(query, classes.teacher.split(&quot; &quot;)[1], classes.teacher.split(&quot; &quot;)[0], classes.date, classes.hour, classes.room.split(&quot;, &quot;)[0], selectedItem.split(&quot;, &quot;)[0], classes.group.split(&quot;, &quot;)[0], classes.subject, classes.group.split(&quot;, &quot;)[1], classes.room.split(&quot;, &quot;)[1], selectedItem.split(&quot;, &quot;)[1])</span>
    }

    /**
     * Zamienia nauczycieli na określonych zajęciach.
     *
     * @param firstTeacher Imię i nazwisko pierwszego nauczyciela w formacie &quot;Nazwisko Imię&quot;.
     * @param secondTeacher Imię i nazwisko drugiego nauczyciela w formacie &quot;Nazwisko Imię&quot;.
     * @param classes Obiekt reprezentujący edytowane zajęcia.
     */
    @Throws(SQLException::class)
    override fun changeTeachers(firstTeacher: String, secondTeacher: String, classes: ClassesToRead) {
<span class="fc" id="L499">        val query = &quot;{ CALL changeTeachers(?,?,?,?,?,?,?,?,?,?,?) }&quot;</span>
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">        val location = if (classes.room.split(&quot;, &quot;)[1] == MessageBundle.getMess(&quot;label.platform&quot;)) &quot;Platform&quot; else classes.room.split(&quot;, &quot;)[1]</span>
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">        val room = if (classes.room.split(&quot;, &quot;)[0] == MessageBundle.getMess(&quot;label.virtual&quot;)) &quot;Virtual&quot; else classes.room.split(&quot;, &quot;)[0]</span>
<span class="fc" id="L502">        return  DBQueryExecutor.executePreparedStatement(query, firstTeacher.split(&quot; &quot;)[1], firstTeacher.split(&quot; &quot;)[0], secondTeacher.split(&quot; &quot;)[1], secondTeacher.split(&quot; &quot;)[0], classes.date, classes.hour, room, classes.group.split(&quot;, &quot;)[0], classes.subject, classes.group.split(&quot;, &quot;)[1], location)</span>
    }

    fun getLocationsNames(): ObservableList&lt;String&gt; {
<span class="fc" id="L506">        val query = &quot;SELECT name FROM location WHERE name!='Platform' ORDER BY name&quot;</span>
<span class="fc" id="L507">        return DBQueryExecutor.executeQuery(query){ resultSet -&gt; resultSet.getString(1) }</span>
    }

    /**
     * Usuwa zajęcia z planu.
     *
     * @param classes Obiekt reprezentujący zajęcia do usunięcia.
     */
    @Throws(SQLException::class)
    override fun deleteClasses(classes: ClassesToRead) {
<span class="fc bfc" id="L517" title="All 2 branches covered.">        val location = if (classes.room.split(&quot;, &quot;)[1] == MessageBundle.getMess(&quot;label.platform&quot;)) &quot;Platform&quot; else classes.room.split(&quot;, &quot;)[1]</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">        val room = if (classes.room.split(&quot;, &quot;)[0] == MessageBundle.getMess(&quot;label.virtual&quot;)) &quot;Virtual&quot; else classes.room.split(&quot;, &quot;)[0]</span>

<span class="fc" id="L520">        val query = &quot;{ CALL deleteFromPlan(?,?,?,?,?,?,?,?,?) }&quot;</span>
<span class="fc" id="L521">        return  DBQueryExecutor.executePreparedStatement(query, classes.date, classes.hour, room, location, classes.group.split(&quot;, &quot;)[0], classes.teacher.split(&quot; &quot;)[1], classes.teacher.split(&quot; &quot;)[0], classes.subject, classes.group.split(&quot;, &quot;)[1])</span>
    }

    /**
     * Metoda, pobierająca tylko te godziny, w których grupa nie ma innych zajęć w danym dniu
     * oraz nauczyciel zgłosił na ten termin dyspozycyjność oraz nie ma innych zajęć
     *
     * @param classesToEdit Obiekt reprezentujący zajęcia do edycji.
     * @return Lista godzin spełniających warunki
     */
    override fun getFreeHours(classesToEdit: ClassesToRead): ObservableList&lt;String&gt; {
<span class="fc" id="L532">        val query = &quot;SELECT hourRange FROM hours AS h WHERE h.hourID NOT IN\n&quot; +</span>
                &quot;(SELECT hourId FROM plan AS p WHERE p.date=? AND p.groupId = \n&quot; +
                &quot;(SELECT g.groupID FROM `groups` AS g INNER JOIN group_field AS gf ON gf.groupID = g.groupID INNER JOIN fields AS f \n&quot; +
                &quot;ON f.fieldID = gf.fieldID WHERE g.groupName=? AND f.fieldName = ?))\n&quot; +
                &quot;AND h.hourID IN \n&quot; +
                &quot;(SELECT hourID FROM availability AS a WHERE a.hourID NOT IN (SELECT hourId FROM plan AS p WHERE p.teacherId = (SELECT teacherID FROM teachers AS t WHERE t.name = ? AND t.lastname = ?)\n&quot; +
                &quot;AND p.date = ?)\n&quot; +
                &quot;AND a.teacherID = (SELECT teacherID FROM teachers AS t WHERE t.name = ? AND t.lastname = ?))&quot;

<span class="fc" id="L541">        return DBQueryExecutor.executeQuery(query, classesToEdit.date, classesToEdit.group.split(&quot;, &quot;)[0], classesToEdit.group.split(&quot;, &quot;)[1], classesToEdit.teacher.split(&quot; &quot;)[1], classesToEdit.teacher.split(&quot; &quot;)[0], classesToEdit.date, classesToEdit.teacher.split(&quot; &quot;)[1], classesToEdit.teacher.split(&quot; &quot;)[0])</span>
<span class="fc" id="L542">        { resultSet -&gt; resultSet.getString(1)}}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>