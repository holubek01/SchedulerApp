<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="pl"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PlansModel.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Scheduler</a> &gt; <a href="index.source.html" class="el_package">com.example.scheduler.models</a> &gt; <span class="el_source">PlansModel.kt</span></div><h1>PlansModel.kt</h1><pre class="source lang-java linenums">package com.example.scheduler.models;

import com.example.scheduler.controller.exceptions.EmptyPlanException
import com.example.scheduler.controller.observers.PlansObserver
import com.example.scheduler.db.dao.*
import com.example.scheduler.objects.PlanForRooms
import com.example.scheduler.utils.CommonUtils
import com.example.scheduler.utils.MessageBundle
import javafx.collections.FXCollections
import javafx.collections.ObservableList
import java.sql.SQLException
import java.time.LocalDate
import java.util.ArrayList

/**
 * Model zawierający logikę biznesową związaną z planami
 */
<span class="fc" id="L18">class PlansModel {</span>
    /**
     * Obiekt zawierajacy zapytania do bazy danych
     */
<span class="fc" id="L22">    private val planDao = PlanDAOImpl()</span>

    /**
     * @see PlanDAOImpl.deletePlan
     */
    @Throws(SQLException::class)
    fun deletePlan(plan: String, hoursLeftTable: String) {
<span class="fc" id="L29">        planDao.deletePlan(plan, hoursLeftTable)</span>
<span class="fc" id="L30">        notifyObservers()</span>
<span class="fc" id="L31">    }</span>

    /**
     * @see PlanDAOImpl.getAllPlans
     */
    fun getAllPlans(): ObservableList&lt;String&gt; {
<span class="fc" id="L37">        return planDao.getAllPlans()</span>
    }

    /**
     * @see PlanDAOImpl.getMaxDateFromTable
     */
    fun getMaxDateFromTable(): LocalDate {
<span class="fc" id="L44">        return planDao.getMaxDateFromTable()</span>
    }

    /**
     * @see PlanDAOImpl.getPlanForPlatform
     */
    fun getPlanForPlatform(): ObservableList&lt;PlanForRooms&gt; {
<span class="fc" id="L51">        return planDao.getPlanForPlatform()</span>
    }

    /**
     * @see PlanDAOImpl.deletePlan
     */
    fun getPlan(location: String, rooms: ObservableList&lt;String&gt;): ObservableList&lt;PlanForRooms&gt; {
<span class="fc" id="L58">        return planDao.getPlan(location, rooms)</span>
    }

    /**
     * @see PlanDAOImpl.getPlanGroup
     */
    fun getPlanGroup(field: String, group: String,day: String): ObservableList&lt;ClassesToRead&gt;{
<span class="fc" id="L65">        val plan = FXCollections.observableArrayList(planDao.getPlanGroup(field, group, day).map { classes -&gt;</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">            if (classes.room == &quot;Virtual, Platform&quot;) {</span>
<span class="fc" id="L67">                classes.copy(room = &quot;${MessageBundle.getMess(&quot;label.virtual&quot;)}, ${MessageBundle.getMess(&quot;label.platform&quot;)}&quot;)</span>
            } else {
<span class="fc" id="L69">                classes</span>
            } })

<span class="fc" id="L72">        return plan</span>
    }

    /**
     * @see PlanDAOImpl.getPlanTeacher
     */
    fun getPlanTeacher(teacher: String, day: String): ObservableList&lt;ClassesToRead&gt;{
<span class="fc" id="L79">        val plan = FXCollections.observableArrayList(planDao.getPlanTeacher(teacher,day).map { classes -&gt;</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">            if (classes.room == &quot;Virtual, Platform&quot;) {</span>
<span class="fc" id="L81">                classes.copy(room = &quot;${MessageBundle.getMess(&quot;label.virtual&quot;)}, ${MessageBundle.getMess(&quot;label.platform&quot;)}&quot;)</span>
            } else {
<span class="fc" id="L83">                classes</span>
            } })

<span class="fc" id="L86">        return plan</span>
    }

    /**
     * @see PlanDAOImpl.shouldSaveOldPlan
     */
    fun shouldSaveOldPlan(): Boolean {
<span class="fc" id="L93">        return planDao.shouldSaveOldPlan()</span>
    }

    /**
     * @see PlanDAOImpl.refillHours
     */
    @Throws(SQLException::class)
    fun refillHours() {
<span class="fc" id="L101">        planDao.refillHours()</span>
<span class="fc" id="L102">    }</span>

    /**
     * @see PlanDAOImpl.createTable
     */
    @Throws(SQLException::class)
    fun createTable(newTable: String, fromTable: String) {
<span class="fc" id="L109">        planDao.createTable(newTable,fromTable)</span>
<span class="fc" id="L110">    }</span>

    /**
     * @see PlanDAOImpl.refillFromOldPlan
     */
    @Throws(SQLException::class)
    fun refillFromOldPlan(tablePlan: String, tableHoursLeft: String) {
<span class="fc" id="L117">        planDao.refillFromOldPlan(tablePlan,tableHoursLeft)</span>
<span class="fc" id="L118">    }</span>

    /**
     * @see PlanDAOImpl.isPlanFull
     */
    fun isPlanFull(): Boolean {
<span class="fc" id="L124">        return planDao.isPlanFull()</span>
    }

    /**
     * @see PlanDAOImpl.checkIfPlanExists
     */
    fun checkIfPlanExists(item: LocalDate): Boolean {
<span class="fc" id="L131">        return planDao.checkIfPlanExists(item)</span>
    }

    /**
     * @see PlanDAOImpl.copyTable
     */
    @Throws(SQLException::class)
    fun copyTable(tableTo: String, tableFrom: String, oldFriday: String, oldSaturday: String, oldSunday: String, newFriday: String, newSaturday: String, newSunday: String) {
<span class="fc" id="L139">        planDao.copyTable(tableTo, tableFrom, oldFriday, oldSaturday, oldSunday, newFriday, newSaturday, newSunday)</span>
<span class="fc" id="L140">        notifyObservers()</span>
<span class="fc" id="L141">    }</span>

    /**
     * Metoda zwracająca wszystkie plany z bazy oprócz aktualnego
     */
    fun getAllPlansExceptCurrent(): ObservableList&lt;String&gt; {
<span class="fc" id="L147">        val plans = getAllPlans()</span>
<span class="fc" id="L148">        val day = getMaxDateFromTable()</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">        if (day!= LocalDate.MIN) {</span>
<span class="fc" id="L150">            val startDay = CommonUtils.getPlanStartDay(day)</span>
<span class="fc" id="L151">            val currentPlan = &quot;plan_$startDay&quot;</span>
<span class="fc" id="L152">            plans.removeIf { it == currentPlan }</span>
        }

<span class="fc" id="L155">        return plans</span>
    }

    /**
     * Metoda tworząca w bazie tabelę z nowym planem
     * @throws EmptyPlanException Jeśli aktualny plan jest pusty
     */
    @Throws(SQLException::class)
    fun createNewPlan() {
<span class="fc" id="L164">        val maxDay = getMaxDateFromTable()</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        if(maxDay!= LocalDate.MIN) {</span>
<span class="fc" id="L166">            val planName = CommonUtils.getPlanStartDay(maxDay)</span>

            //Mamy nazwę, teraz trzeba utworzyć tabele
<span class="fc" id="L169">            createTable(&quot;plan_$planName&quot;,&quot;plan&quot;)</span>
<span class="fc" id="L170">            val fromTable = &quot;group_subject_hours_left&quot;</span>
<span class="fc" id="L171">            createTable(&quot;${fromTable}_$planName&quot;,&quot;group_subject_hours_left&quot;)</span>
<span class="fc" id="L172">            notifyObservers()</span>
        }
<span class="nc" id="L174">        else throw EmptyPlanException(MessageBundle.getMess(&quot;warning.savePlanError&quot;))</span>
<span class="fc" id="L175">    }</span>

    /**
     * Metoda usuwająca aktualny plan zajęć z bazy
     * @throws EmptyPlanException Jeśli aktualny plan jest pusty
     */
    @Throws(SQLException::class)
    fun deleteCurrentPlan() {
<span class="nc" id="L183">        val maxDay = getMaxDateFromTable()</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if(maxDay!= LocalDate.MIN) {</span>
<span class="nc" id="L185">            val planStart = CommonUtils.getPlanStartDay(maxDay)</span>
<span class="nc" id="L186">            val planName = &quot;plan_$planStart&quot;</span>
<span class="nc" id="L187">            val hoursLeftName = &quot;group_subject_hours_left_$planStart&quot;</span>
<span class="nc" id="L188">            deletePlan(planName, hoursLeftName)</span>
<span class="nc" id="L189">            refillHours()</span>
        }
<span class="nc" id="L191">        else throw EmptyPlanException(MessageBundle.getMess(&quot;warning.deletePlansError&quot;))</span>
<span class="nc" id="L192">    }</span>


    /**
     * Tworzy listę początków planów (piątki) między podanymi datami.
     *
     * @param from Początkowa data.
     * @param to   Końcowa data.
     * @return Lista początków planów między podanymi datami.
     */
    fun createArrayOfDays(from: LocalDate, to: LocalDate): List&lt;LocalDate&gt; {
<span class="fc" id="L203">        val daysList = ArrayList&lt;LocalDate&gt;()</span>
<span class="fc" id="L204">        var currentDay = from</span>

<span class="fc bfc" id="L206" title="All 2 branches covered.">        while (!currentDay.isAfter(to)) {</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">            if (!checkIfPlanExists(currentDay)) daysList.add(currentDay)</span>
<span class="fc" id="L208">            currentDay = currentDay.plusDays(7)</span>
        }

<span class="fc" id="L211">        return daysList</span>
    }


    /**
     * Obiekt narzędziowy, umożliwiający rejestrowanie i powiadamianie obserwatorów o zmianach w
     * planach zajęciowych (dodanie lub usunięcie planu).
     */
    companion object {
        /**
         * Lista obserwatorów
         */
<span class="fc" id="L223">        private val observers = mutableListOf&lt;PlansObserver&gt;()</span>

        /**
         * Metoda dodająca obserwatora do listy obserwatorów.
         *
         * @param observer Obserwator, który ma zostać dodany do listy obserwatorów.
         */
        fun addObserver(observer: PlansObserver) {
<span class="fc" id="L231">            observers.add(observer)</span>
<span class="fc" id="L232">        }</span>

        /**
         * Metodą służąca do powiadamiania wszystkich zarejestrowanych obserwatorów o zmianach.
         */
        fun notifyObservers() {
<span class="fc" id="L238">            observers.forEach { it.onPlansChanged() }</span>
<span class="fc" id="L239">        }</span>
    }



}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>